<!DOCTYPE html>
<html>
<head>
    <title>W&B PHATE Structure Labeling - Multi-Select</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .header { background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); color: white; padding: 20px; margin: -20px -20px 20px -20px; }
        .header h1 { margin: 0 0 5px 0; }
        .header p { margin: 0; opacity: 0.8; font-size: 14px; }
        .progress { background: #ecf0f1; border-radius: 10px; height: 20px; margin: 15px 0 10px 0; }
        .progress-bar { background: #27ae60; height: 100%; border-radius: 10px; transition: width 0.3s; }
        .stats { display: flex; gap: 15px; margin: 10px 0; flex-wrap: wrap; }
        .stat { background: #34495e; padding: 8px 15px; border-radius: 5px; font-size: 13px; }
        .stat-group { background: #1a252f; padding: 10px 15px; border-radius: 5px; }
        .stat-group-title { font-size: 11px; opacity: 0.7; margin-bottom: 5px; }
        .stat-group-items { display: flex; gap: 10px; flex-wrap: wrap; }
        .stat-item { font-size: 12px; }

        .controls { background: white; padding: 15px; border-radius: 10px; margin-bottom: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .controls button { padding: 10px 20px; margin-right: 10px; margin-bottom: 5px; cursor: pointer; border: none; border-radius: 5px; font-size: 14px; }
        .controls button:hover { opacity: 0.9; }
        .btn-export { background: #27ae60; color: white; }
        .btn-filter { background: #3498db; color: white; }
        .btn-filter.active { background: #2980b9; box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); }
        .btn-clear { background: #e74c3c; color: white; }
        .search-box { padding: 10px 15px; border: 1px solid #ddd; border-radius: 5px; width: 250px; margin-right: 15px; }

        .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(480px, 1fr)); gap: 20px; }
        .card { background: white; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; transition: all 0.2s; }
        .card.labeled { border-left: 5px solid #27ae60; }
        .card.flagged { border: 3px solid #f39c12 !important; }
        .card img { width: 100%; height: auto; display: block; cursor: pointer; }
        .card img:hover { opacity: 0.95; }
        .card-body { padding: 15px; }

        .label-badge { position: absolute; top: 10px; left: 10px; padding: 4px 10px; border-radius: 12px; font-size: 11px; font-weight: bold; color: white; z-index: 10; display: none; max-width: 200px; }
        .card.labeled .label-badge { display: block; }

        .card-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 5px; gap: 10px; }
        .card-title { font-size: 14px; font-weight: bold; color: #2c3e50; flex: 1; }
        .flag-btn { background: none; border: 2px solid #f39c12; color: #f39c12; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.2s; white-space: nowrap; }
        .flag-btn:hover { background: #fef5e7; }
        .flag-btn.flagged { background: #f39c12; color: white; }

        .primary-label { margin-bottom: 12px; }
        .primary-label-title { font-size: 11px; color: #7f8c8d; margin-bottom: 6px; font-weight: 600; }
        .label-buttons { display: flex; gap: 5px; flex-wrap: wrap; }
        .label-btn { padding: 6px 10px; border: 2px solid #ddd; background: white; cursor: pointer; border-radius: 5px; font-size: 11px; transition: all 0.2s; position: relative; }
        .label-btn:hover { border-color: #3498db; background: #f8f9fa; }
        .label-btn.selected { color: white; }
        .label-btn.selected::after { content: "✓"; position: absolute; top: -5px; right: -5px; background: white; color: #2c3e50; width: 16px; height: 16px; border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; border: 2px solid currentColor; }

        .label-btn[data-label="clusters"].selected { background: #e74c3c; border-color: #e74c3c; }
        .label-btn[data-label="simple_traj"].selected { background: #f39c12; border-color: #f39c12; }
        .label-btn[data-label="bifurcation"].selected { background: #27ae60; border-color: #27ae60; }
        .label-btn[data-label="multi_branch"].selected { background: #3498db; border-color: #3498db; }
        .label-btn[data-label="complex_tree"].selected { background: #9b59b6; border-color: #9b59b6; }
        .label-btn[data-label="cyclic"].selected { background: #1abc9c; border-color: #1abc9c; }
        .label-btn[data-label="surface"].selected { background: #d35400; border-color: #d35400; }
        .label-btn[data-label="batch_effect"].selected { background: #95a5a6; border-color: #95a5a6; }

        .color-legend-section { background: #fdf6e3; border: 1px solid #f0e6d2; border-radius: 5px; margin-bottom: 12px; }
        .color-legend-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; cursor: pointer; }
        .color-legend-header:hover { background: #f5edd5; }
        .color-legend-title { font-size: 11px; font-weight: 600; color: #8e6f3a; display: flex; align-items: center; gap: 5px; }
        .color-legend-label { font-size: 10px; color: #8e44ad; background: #f5eef8; padding: 2px 6px; border-radius: 3px; margin-left: 5px; }
        .color-legend-toggle { font-size: 10px; color: #8e6f3a; }
        .color-legend-body { padding: 8px 10px; border-top: 1px solid #f0e6d2; display: none; }
        .color-legend-body.open { display: block; }

        .secondary-labels { border-top: 1px solid #eee; padding-top: 12px; margin-top: 12px; }
        .annotation-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .annotation-item label { font-size: 11px; color: #7f8c8d; display: block; margin-bottom: 3px; font-weight: 500; }
        .annotation-item select { width: 100%; padding: 6px 8px; font-size: 11px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; }
        .annotation-item select:focus { border-color: #3498db; outline: none; }
        .annotation-item select.filled { border-color: #27ae60; background: #f0fff4; }

        .notes-section { margin-top: 10px; }
        .notes { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 12px; resize: vertical; min-height: 40px; }
        .notes:focus { border-color: #3498db; outline: none; }

        .header-legend { margin: 15px 0; padding: 15px; background: #1a252f; border-radius: 8px; }
        .header-legend-title { font-size: 12px; font-weight: 600; margin-bottom: 10px; opacity: 0.9; }
        .header-legend-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 8px; }
        .header-legend-item { display: flex; align-items: center; gap: 8px; font-size: 11px; }
        .header-legend-color { width: 14px; height: 14px; border-radius: 3px; flex-shrink: 0; }

        .image-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); }
        .image-modal-content { max-width: 90%; max-height: 90%; margin: auto; display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .image-modal-close { position: absolute; top: 20px; right: 30px; color: white; font-size: 40px; cursor: pointer; }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="header">
        <h1>W&B PHATE Structure Labeling - Multi-Select</h1>
        <p>Select multiple structure types for each PHATE visualization</p>
        <div class="progress"><div class="progress-bar" id="progressBar" style="width: 0%"></div></div>
        <div class="stats">
            <div class="stat"><strong><span id="labeledCount">0</span></strong> / <span id="totalCount">0</span> labeled</div>
            <div class="stat"><strong><span id="multiSelectCount">0</span></strong> multi-structure</div>
            <div class="stat"><strong><span id="annotatedCount">0</span></strong> annotated</div>
            <div class="stat"><strong><span id="notesCount">0</span></strong> with notes</div>
            <div class="stat" style="background:#f39c12"><strong><span id="flaggedCount">0</span></strong> flagged</div>
        </div>
        <div class="stats">
            <div class="stat-group">
                <div class="stat-group-title">PRIMARY STRUCTURE (Multi-Select)</div>
                <div class="stat-group-items">
                    <span class="stat-item">Clusters: <strong id="count_clusters">0</strong></span>
                    <span class="stat-item">Simple Traj: <strong id="count_simple_traj">0</strong></span>
                    <span class="stat-item">Bifurcation: <strong id="count_bifurcation">0</strong></span>
                    <span class="stat-item">Multi-Branch: <strong id="count_multi_branch">0</strong></span>
                    <span class="stat-item">Complex Tree: <strong id="count_complex_tree">0</strong></span>
                    <span class="stat-item">Cyclic: <strong id="count_cyclic">0</strong></span>
                    <span class="stat-item">Surface: <strong id="count_surface">0</strong></span>
                    <span class="stat-item">Batch Effect: <strong id="count_batch_effect">0</strong></span>
                </div>
            </div>
        </div>
        <div class="header-legend">
            <div class="header-legend-title">STRUCTURE TYPES & COLORS</div>
            <div class="header-legend-grid">
                <div class="header-legend-item"><div class="header-legend-color" style="background:#e74c3c"></div> Clusters</div>
                <div class="header-legend-item"><div class="header-legend-color" style="background:#f39c12"></div> Simple Trajectory</div>
                <div class="header-legend-item"><div class="header-legend-color" style="background:#27ae60"></div> Bifurcation</div>
                <div class="header-legend-item"><div class="header-legend-color" style="background:#3498db"></div> Multi-Branch</div>
                <div class="header-legend-item"><div class="header-legend-color" style="background:#9b59b6"></div> Complex Tree</div>
                <div class="header-legend-item"><div class="header-legend-color" style="background:#1abc9c"></div> Cyclic</div>
                <div class="header-legend-item"><div class="header-legend-color" style="background:#d35400"></div> Surface</div>
                <div class="header-legend-item"><div class="header-legend-color" style="background:#95a5a6"></div> Batch Effect</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <input type="text" class="search-box" id="searchBox" placeholder="Search datasets..." onkeyup="filterBySearch()">
        <button class="btn-export" onclick="exportLabels()">Export Multi-Select JSON</button>
        <button class="btn-filter" onclick="filterCards('all')">Show All</button>
        <button class="btn-filter" onclick="filterCards('unlabeled')">Unlabeled Only</button>
        <button class="btn-filter" onclick="filterCards('labeled')">Labeled Only</button>
        <button class="btn-filter" onclick="filterCards('multi')">Multi-Structure Only</button>
        <button class="btn-filter" onclick="filterCards('annotated')">Annotated Only</button>
        <button class="btn-filter" onclick="filterCards('notes')">With Notes</button>
        <button class="btn-clear" onclick="if(confirm('Clear all data (labels, annotations, notes)?')) clearAll()">Clear All</button>
    </div>

    <div class="gallery" id="gallery">
        <div style="grid-column: 1/-1; text-align: center; padding: 50px; color: #7f8c8d;">
            Loading PHATE gallery data...
        </div>
    </div>

    <div class="image-modal" id="imageModal" onclick="closeModal()">
        <span class="image-modal-close" onclick="closeModal()">&times;</span>
        <img class="image-modal-content" id="modalImage">
    </div>

    <script>
        // Data storage
        let wandbData = {};
        let runColors = {};
        let labels = {};
        let annotations = {density: {}, quality: {}};
        let notes = {};
        let flagged = new Set();
        let currentFilter = 'all';

        const primaryTypes = ['clusters', 'simple_traj', 'bifurcation', 'multi_branch', 'complex_tree', 'cyclic', 'surface', 'batch_effect'];

        const labelColors = {
            clusters: '#e74c3c',
            simple_traj: '#f39c12',
            bifurcation: '#27ae60',
            multi_branch: '#3498db',
            complex_tree: '#9b59b6',
            cyclic: '#1abc9c',
            surface: '#d35400',
            batch_effect: '#95a5a6'
        };

        // Generate dynamic category names based on label_key
        function generateCategoryNames(labelKey, count, runId) {
            const key = labelKey.toLowerCase();
            const names = [];

            // Check if we have actual categories for this run
            if (window.labelCategories && window.labelCategories[runId]) {
                const actualCategories = window.labelCategories[runId].categories || [];
                const numActual = Math.min(count, actualCategories.length);
                for (let i = 0; i < numActual; i++) {
                    names.push(actualCategories[i]);
                }
                // Pad with generic names if needed
                for (let i = numActual; i < count; i++) {
                    names.push(`Category ${i + 1}`);
                }
                return names;
            }

            // Fall back to generic names if no actual categories
            if (key.includes('development_stage') || key.includes('stage')) {

            if (key.includes('development_stage') || key.includes('stage')) {
                for (let i = 0; i < count; i++) {
                    names.push(`Stage ${i + 1}`);
                }
            } else if (key.includes('day') || key.includes('time')) {
                for (let i = 0; i < count; i++) {
                    names.push(`Time ${i + 1}`);
                }
            } else if (key.includes('cluster') || key.includes('cluster_id')) {
                for (let i = 0; i < count; i++) {
                    names.push(`Cluster ${i}`);
                }
            } else if (key.includes('cell_type') || key.includes('cell') || key.includes('class')) {
                const cellTypes = ['Type A', 'Type B', 'Type C', 'Type D', 'Type E',
                                'Type F', 'Type G', 'Type H', 'Type I', 'Type J'];
                for (let i = 0; i < count; i++) {
                    names.push(cellTypes[i % cellTypes.length]);
                }
            } else if (key.includes('region') || key.includes('tissue')) {
                for (let i = 0; i < count; i++) {
                    names.push(`Region ${i + 1}`);
                }
            } else {
                for (let i = 0; i < count; i++) {
                    names.push(`Category ${i + 1}`);
                }
            }
            return names;
        }

        // Create dynamic color legend using actual extracted colors
        function createPlotLegend(runData, runInfo) {
                const name = categoryNames[i % categoryNames.length];
                colorExamples += `
                    <div style="display: flex; align-items: center; gap: 8px; margin: 2px 0;">
                        <div style="width: 14px; height: 14px; background: ${color}; border-radius: 3px; border: 1px solid #ccc; flex-shrink: 0;"></div>
                        <span style="font-size: 11px; color: #2c3e50;">${name}</span>
                    </div>`;
            }

            if (numCategories > maxExamples) {
                colorExamples += `
                    <div style="font-size: 10px; color: #7f8c8d; font-style: italic; padding-left: 22px;">
                        ... and ${numCategories - maxExamples} more categories
                    </div>`;
            }

            return `
                <div class="color-legend-section">
                    <div class="color-legend-header" onclick="toggleColorLegend(this)">
                        <div class="color-legend-title">
                            ${actualLabelKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}
                            <span class="color-legend-label">${numCategories} categories</span>
                        </div>
                        <div class="color-legend-toggle">▶</div>
                    </div>
                    <div class="color-legend-body">
                        ${legendInfo.map(info => `<div style="margin: 4px 0; color: #2c3e50; font-size: 11px;">${info}</div>`).join('')}
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0e6d2;">
                            <div style="font-size: 10px; color: #8e6f3a; margin-bottom: 8px; font-weight: 600;">Color Legend (${numCategories} total):</div>
                            ${colorExamples}
                        </div>
                        <div style="margin-top: 8px; font-size: 9px; color: #95a5a6; font-style: italic;">
                            ${hasActualColors ? '* Colors extracted from actual PHATE plot images' : '* Colors may vary in actual plot'}
                        </div>
                    </div>
                </div>
            `;
        }

        function createLabelButtons(runId, selectedLabels) {
            return primaryTypes.map(type => {
                const isSelected = selectedLabels.includes(type);
                const displayName = type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                return `<button class="label-btn ${isSelected ? 'selected' : ''}" data-label="${type}" onclick="toggleStructure('${runId}', '${type}')">
                    ${displayName}
                </button>`;
            }).join('');
        }

        function toggleColorLegend(header) {
            const body = header.nextElementSibling;
            const toggle = header.querySelector('.color-legend-toggle');
            if (body.classList.contains('open')) {
                body.classList.remove('open');
                toggle.textContent = '▶';
            } else {
                body.classList.add('open');
                toggle.textContent = '▼';
            }
        }

        function setAnnotation(runId, field, value) {
            if (value) {
                annotations[field][runId] = value;
                event.target.classList.add('filled');
            } else {
                delete annotations[field][runId];
                event.target.classList.remove('filled');
            }
            saveToStorage();
            updateStats();
        }

        function setNotes(runId, value) {
            if (value.trim()) {
                notes[runId] = value.trim();
            } else {
                delete notes[runId];
            }
            saveToStorage();
            updateStats();
        }

        function toggleStructure(runId, structureType) {
            if (!labels[runId]) {
                labels[runId] = [];
            }

            const card = document.querySelector(`[data-run-id="${runId}"]`);
            const button = card.querySelector(`[data-label="${structureType}"]`);

            if (labels[runId].includes(structureType)) {
                labels[runId] = labels[runId].filter(s => s !== structureType);
                button.classList.remove('selected');
            } else {
                labels[runId].push(structureType);
                button.classList.add('selected');
            }

            if (labels[runId].length > 0) {
                card.classList.add('labeled');
            } else {
                card.classList.remove('labeled');
            }

            updateCardBadge(runId);
            updateStats();
            saveToStorage();
        }

        function updateCardBadge(runId) {
            const card = document.querySelector(`[data-run-id="${runId}"]`);
            const badge = card.querySelector('.label-badge');
            const runLabels = labels[runId] || [];

            if (runLabels.length === 0) {
                badge.style.display = 'none';
            } else {
                badge.style.display = 'block';
                if (runLabels.length === 1) {
                    badge.textContent = runLabels[0].replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    badge.style.background = labelColors[runLabels[0]];
                } else {
                    badge.textContent = `${runLabels.length} structures`;
                    const colors = runLabels.slice(0, 3).map(l => labelColors[l]).join(', ');
                    badge.style.background = `linear-gradient(45deg, ${colors})`;
                }
            }
        }

        function toggleFlag(runId) {
            const card = document.querySelector(`[data-run-id="${runId}"]`);
            const btn = card.querySelector('.flag-btn');

            if (flagged.has(runId)) {
                flagged.delete(runId);
                btn.classList.remove('flagged');
                btn.textContent = 'Flag';
                card.classList.remove('flagged');
            } else {
                flagged.add(runId);
                btn.classList.add('flagged');
                btn.textContent = 'FLAGGED';
                card.classList.add('flagged');
            }
            saveToStorage();
            updateStats();
        }

        function updateStats() {
            const total = Object.keys(wandbData).length;
            const labeled = Object.values(labels).filter(l => l.length > 0).length;
            const multiSelect = Object.values(labels).filter(l => l.length > 1).length;
            const annotated = Object.values(annotations.density).filter(v => v).length +
                            Object.values(annotations.quality).filter(v => v).length;
            const withNotes = Object.keys(notes).length;

            document.getElementById('totalCount').textContent = total;
            document.getElementById('labeledCount').textContent = labeled;
            document.getElementById('multiSelectCount').textContent = multiSelect;
            document.getElementById('annotatedCount').textContent = annotated;
            document.getElementById('notesCount').textContent = withNotes;
            document.getElementById('flaggedCount').textContent = flagged.size;

            document.getElementById('progressBar').style.width = `${(labeled / total) * 100}%`;

            // Count each structure type
            primaryTypes.forEach(type => {
                const count = Object.values(labels).filter(l => l.includes(type)).length;
                document.getElementById(`count_${type}`).textContent = count;
            });
        }

        function filterCards(filterType) {
            currentFilter = filterType;
            document.querySelectorAll('.btn-filter').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            document.querySelectorAll('.card').forEach(card => {
                const runId = card.dataset.runId;
                const runLabels = labels[runId] || [];
                const isLabeled = runLabels.length > 0;
                const isMulti = runLabels.length > 1;
                const isAnnotated = annotations.density[runId] || annotations.quality[runId];
                const hasNotes = notes[runId];
                const isFlagged = flagged.has(runId);

                let show = false;
                switch(filterType) {
                    case 'all': show = true; break;
                    case 'unlabeled': show = !isLabeled; break;
                    case 'labeled': show = isLabeled; break;
                    case 'multi': show = isMulti; break;
                    case 'annotated': show = isAnnotated; break;
                    case 'notes': show = hasNotes; break;
                    case 'flagged': show = isFlagged; break;
                }

                card.classList.toggle('hidden', !show);
            });
        }

        function filterBySearch() {
            const query = document.getElementById('searchBox').value.toLowerCase();
            document.querySelectorAll('.card').forEach(card => {
                const title = card.querySelector('.card-title').textContent.toLowerCase();
                const runId = card.dataset.runId.toLowerCase();
                card.classList.toggle('hidden', !title.includes(query) && !runId.includes(query));
            });
        }

        function exportLabels() {
            const exportData = {
                exportDate: new Date().toISOString(),
                totalRuns: Object.keys(wandbData).length,
                labeledRuns: Object.keys(labels).filter(k => labels[k].length > 0).length,
                labels: labels,
                annotations: annotations,
                notes: Array.from(flagged).reduce((acc, k) => { acc[k] = notes[k] || ''; return acc; }, {}),
                flagged: Array.from(flagged)
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `phate_labels_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearAll() {
            labels = {};
            annotations = {density: {}, quality: {}};
            notes = {};
            flagged.clear();
            localStorage.removeItem('phateGalleryLabels');
            localStorage.removeItem('phateGalleryAnnotations');
            localStorage.removeItem('phateGalleryNotes');
            localStorage.removeItem('phateGalleryFlagged');
            renderGallery();
            updateStats();
        }

        function saveToStorage() {
            localStorage.setItem('phateGalleryLabels', JSON.stringify(labels));
            localStorage.setItem('phateGalleryAnnotations', JSON.stringify(annotations));
            localStorage.setItem('phateGalleryNotes', JSON.stringify(Array.from(notes.entries())));
            localStorage.setItem('phateGalleryFlagged', JSON.stringify(Array.from(flagged)));
        }

        function loadFromStorage() {
            try {
                const savedLabels = localStorage.getItem('phateGalleryLabels');
                if (savedLabels) labels = JSON.parse(savedLabels);

                const savedAnnotations = localStorage.getItem('phateGalleryAnnotations');
                if (savedAnnotations) annotations = JSON.parse(savedAnnotations);

                const savedNotes = localStorage.getItem('phateGalleryNotes');
                if (savedNotes) notes = Object.fromEntries(JSON.parse(savedNotes));

                const savedFlagged = localStorage.getItem('phateGalleryFlagged');
                if (savedFlagged) flagged = new Set(JSON.parse(savedFlagged));
            } catch (e) {
                console.warn('Error loading from storage:', e);
            }
        }

        function openModal(imageSrc) {
            document.getElementById('modalImage').src = imageSrc;
            document.getElementById('imageModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('imageModal').style.display = 'none';
        }

        async function loadData() {
            try {
                // Load run colors
                const colorsResponse = await fetch('run_colors.json');
                if (colorsResponse.ok) {
                    runColors = await colorsResponse.json();
                    console.log(`Loaded colors for ${Object.keys(runColors).length} runs`);
                }

                // Load label categories (actual category names from h5ad)
                const labelCategoriesResponse = await fetch('label_categories.json');
                if (labelCategoriesResponse.ok) {
                    window.labelCategories = await labelCategoriesResponse.json();
                    console.log(`Loaded actual label categories for ${Object.keys(window.labelCategories).length} runs`);
                }

                // Load wandb metadata
                const response = await fetch('wandb_metadata.json');
                if (response.ok) {
                    wandbData = await response.json();
                }

                loadFromStorage();
                renderGallery();
                updateStats();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('gallery').innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; padding: 50px; color: #e74c3c;">
                        Error loading gallery data. Please refresh the page.
                    </div>`;
            }
        }

        function createCard(runId) {
            const runData = wandbData[runId] || {};
            const runLabels = labels[runId] || [];
            const isLabeled = runLabels.length > 0;
            const isFlagged = flagged.has(runId);
            const runInfo = runColors[runId] || {};

            // Get actual label key from config
            const actualLabelKey = runData.config?.data?.value?.label_key || runData.label_key || 'N/A';

            const imagePath = `images/${runId}.png`;
            const numCategories = runInfo.num_categories || runInfo.colors?.length || '?';

            // Create badge
            let badgeHTML = '';
            if (runLabels.length === 1) {
                const displayName = runLabels[0].replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                badgeHTML = `<div class="label-badge" style="background: ${labelColors[runLabels[0]]}; display: ${isLabeled ? 'block' : 'none'};">${displayName}</div>`;
            } else if (runLabels.length > 1) {
                badgeHTML = `<div class="label-badge" style="background: linear-gradient(45deg, ${runLabels.slice(0, 3).map(l => labelColors[l]).join(', ')}); display: block;">${runLabels.length} structures</div>`;
            }

            const card = document.createElement('div');
            card.className = 'card';
            if (isLabeled) card.classList.add('labeled');
            if (isFlagged) card.classList.add('flagged');
            card.dataset.runId = runId;

            card.innerHTML = `
                ${badgeHTML || '<div class="label-badge" style="display:none;"></div>'}
                <img src="${imagePath}" alt="PHATE visualization" onclick="openModal('${imagePath}')"
                     onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjhmOWZhIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNiIgZmlsbD0iIzk1YTVhNiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vdCBmb3VuZDwvdGV4dD48L3N2Zz4='">
                <div class="card-body">
                    <div class="card-header">
                        <div class="card-title">${runData.dataset_name || 'Unknown Dataset'}</div>
                        <button class="flag-btn ${isFlagged ? 'flagged' : ''}" onclick="toggleFlag('${runId}')">
                            ${isFlagged ? 'FLAGGED' : 'Flag'}
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #95a5a6; margin-bottom: 10px;">
                        Run: ${runId} | Label: ${actualLabelKey} | ${numCategories} classes
                    </div>

                    ${createPlotLegend(runData, runInfo)}

                    <div class="primary-label">
                        <div class="primary-label-title">STRUCTURE TYPES (Click multiple)</div>
                        <div class="label-buttons">
                            ${createLabelButtons(runId, runLabels)}
                        </div>
                    </div>

                    <div class="secondary-labels">
                        <div class="annotation-grid">
                            <div class="annotation-item">
                                <label>Density Pattern:</label>
                                <select onchange="setAnnotation('${runId}', 'density', this.value)" class="${annotations.density[runId] ? 'filled' : ''}">
                                    <option value="">Select...</option>
                                    <option value="uniform" ${annotations.density[runId] === 'uniform' ? 'selected' : ''}>Uniform</option>
                                    <option value="sparse" ${annotations.density[runId] === 'sparse' ? 'selected' : ''}>Sparse</option>
                                    <option value="dense_core" ${annotations.density[runId] === 'dense_core' ? 'selected' : ''}>Dense Core</option>
                                    <option value="gradient" ${annotations.density[runId] === 'gradient' ? 'selected' : ''}>Gradient</option>
                                </select>
                            </div>
                            <div class="annotation-item">
                                <label>Quality:</label>
                                <select onchange="setAnnotation('${runId}', 'quality', this.value)" class="${annotations.quality[runId] ? 'filled' : ''}">
                                    <option value="">Select...</option>
                                    <option value="excellent" ${annotations.quality[runId] === 'excellent' ? 'selected' : ''}>Excellent</option>
                                    <option value="good" ${annotations.quality[runId] === 'good' ? 'selected' : ''}>Good</option>
                                    <option value="fair" ${annotations.quality[runId] === 'fair' ? 'selected' : ''}>Fair</option>
                                    <option value="poor" ${annotations.quality[runId] === 'poor' ? 'selected' : ''}>Poor</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="notes-section">
                        <textarea class="notes" placeholder="Additional notes..." onchange="setNotes('${runId}', this.value)">${notes[runId] || ''}</textarea>
                    </div>
                </div>
            `;

            return card;
        }

        function renderGallery() {
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';

            const runIds = Object.keys(wandbData).sort();
            runIds.forEach(runId => {
                const card = createCard(runId);
                gallery.appendChild(card);
            });

            document.getElementById('totalCount').textContent = runIds.length;
        }

        // Initialize
        loadData();
    </script>
</body>
</html>
